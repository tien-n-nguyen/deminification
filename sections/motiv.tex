\section{Motivation and Approach Overview}
\label{example_section}

Figures~\ref{example_org} and~\ref{example_sim} show the
original and minified versions~of the JS function
\texttt{get\-Clip\-board\-Content} in the \texttt{vue-medium-ed\-itor}
project.
%~The original version is shown in Figure~\ref{example_org}.
%
The function is to retrieve the content of~the~clipboard. In the minified code, all local variables~are
randomly renamed with short and meaningless names, \eg
\texttt{data\-Transfer} becomes \texttt{r}, \texttt{data} becomes
\texttt{n}, by a minification tool, \eg UglifyJS \cite{uglify}. This
makes developers difficult to comprehend~it.

%\begin{figure*}
%\begin{subfigure}[b]{.5\linewidth}
%\centering\large 
%\lstinputlisting[captionpos=b, numbers=left, stepnumber=1, numbersep=-6pt,
    %frame=single, xleftmargin=4pt, xrightmargin=4pt]{example_simplified.js}
%\caption{A subfigure}\label{fig:1a}
%\end{subfigure}%
%\begin{subfigure}[b]{.5\linewidth}
%\centering\large 
%\lstinputlisting[captionpos=b, numbers=left, stepnumber=1, numbersep=-6pt,
    %frame=single, xleftmargin=4pt, xrightmargin=4pt]{example.js}
%\caption{Another subfigure}\label{fig:1b}
%\end{subfigure}
%\caption{A figure}\label{fig:1}
%\end{figure*}

%\begin{figure}[t]
%\begin{center}
%\lstinputlisting[captionpos=b, numbers=left, stepnumber=1, numbersep=-6pt,
    %frame=single, xleftmargin=4pt, xrightmargin=4pt]{example_simplified.js}
%\caption{A minified code from a real-world example.}
%\label{example_sim}
%\end{center}
%\end{figure}

\begin{figure}[t]
\begin{center}
\lstinputlisting[captionpos=b, numbers=left, stepnumber=1, numbersep=-6pt,
    frame=single, xleftmargin=4pt, xrightmargin=4pt]{example.js}
%\caption{The Original Code of the Minified Code in Figure~\ref{example_sim}}
\caption{An Original Code from a Project in GitHub}
\label{example_org}
\end{center}
\end{figure}

\begin{figure}[t]
\begin{center}
\lstinputlisting[captionpos=b, numbers=left, stepnumber=1, numbersep=-6pt,
    frame=single, xleftmargin=4pt, xrightmargin=4pt]{example_simplified.js}
%\caption{A Minified Code from a Real-World Example}
\caption{The Minified Code for the Code in Figure~\ref{example_org}}
\label{example_sim}
\end{center}
\end{figure}



Our goal is to assign meaningful names for the variables in the
minified code.
%
The name chosen for a variable in the code should be {\em natural}
(unsurprising) in the context~\cite{JSNaughty2017} and follow naming
conventions~\cite{barr-codeconvention-fse14}, so that the de-minified
code becomes easy to understand for developers.


To achieve this goal, we conjecture that the meaningful names of
minified variables could be observed in a large corpus of existing
source code. This motivates us to conform our approach to a {\em
  data-driven direction}, where we learn the names from original source
code to recover the names for variables in the minified code.
%
Indeed, for the minified code in Figure~\ref{example_sim}, all
original names are found in our experimental dataset that contains
322K JS files collected from 12K GitHub~projects.
%

\subsection{Observations}

The name recovering process of variables in
minified code is affected by multiple factors. Let us illustrate these
factors through the following observations:

\textbf{O1}. \textit{Each individual variable has certain properties
  and plays particular roles in the code. Thus, the name of a variable
  is intuitively affected by its properties and roles}. The properties
are the method calls or field accesses to which a variable of a certain
type can access.
%
%Due to the nature of naming, 
If a method is called or a field is accessed
by a variable, the name of the variable should be compatible with the
method's or the field's name.
%
%the name of the variable should be compatible with the name of the
%method being called or the name of the field being accessed.
% Tien
%
%In a non-minified code, it is not expected for a random name to be the
%name of a variable that calls certain method.
%
For example, in our experimental dataset,
%(will be explained later),
the number of candidates that can call method \texttt{getData()}
(lines 6 and 14) is only 7 out of 31 variables names found in a
function named \texttt{getClipboardContent}.
%
%, such as \texttt{dataTransfer} or \texttt{dataObj}.
%
Such number is down to a \textit{single} candidate if we additionally
consider that it can also access the fields \texttt{getData} (line 5)
and \texttt{types} (line 11). Thus, \texttt{r} could be named
as \texttt{dataTransfer}, which is the same name in the
original code in Figure~\ref{example_org}. For the variable \texttt{f}
that is created and assigned as an element of the array
\texttt{types[]} at line 13, there are 4 candidates for such
variable that can be used as an argument of the method named
\texttt{getData()} (line~14). The number of candidates for \texttt{i},
which is the returned result of the call to \texttt{getData()} (line
6) and also has a field with the name \texttt{length} (line 7), is
only 7.

%
\textbf{O2}. \textit{In a function, a variable might collaborate with
  other variables to implement the function. Consequently, the
  recovering name for a variable might be influenced by the name of
  others}. Intuitively, since the variables are used together, their
names are often consistent with each other to achieve the
common task in the function.
%
In the example, in 28 possible pairs of candidates for \texttt{i} (7
candidates) and \texttt{f} (4 candidates), there are only 2 pairs of
candidates that are used to name two variables in the same function
in our dataset. One of them is the correct pair, which is
\texttt{legacyText} and \texttt{contentType}.
%
%experimental

\textbf{O3.} \textit{Within a function, e.g.,
  \texttt{getClipboardContent}, a variable name, e.g.,
  \texttt{contentType} is affected by the specific task of the
  function that is described by the function's
  name~\cite{sutton-fse15}}.~This is intuitive because the names of
variables are often~relevant~to the task that the variables are used
in the code~to~achieve. Such task is typically described with a
succinct function~name.
%containing the variables.
In Figure~\ref{example_org}, the task of~the function is to get the
clipboard's content, thus, it is named
\texttt{get\-ClipboardContent}. In our~dataset, there are 31
names being used to specify~the variables in function
\texttt{getClipboardContent}, \eg \texttt{data},
\texttt{dataTransfer}, \texttt{contentType}.
%\texttt{content}.
Meanwhile, the variable names \texttt{students}
or \texttt{salary} have never been used in the function with that
name.

%the variables named \texttt{salary} or \texttt{students} are never
%used in a function with the name of \texttt{getClipboardContent}.

Overall, these observations indicate that the names of the variables
in a particular function not only depend on {\em the task} in which
the variable is used to implement (called {\bf task-specific context}), but
their names are also affected by {\em their own properties and roles} in the
code (called {\bf single-variable usage context}) and on the {\em names of the
other variables} in the same function (called {\bf multiple-variable usage
  context}).

\subsection{Approach Overview}

From the observations, we propose an IR-based, data-driven approach to
recover the variables' names in a minified JS code based
on the contextual information
%of the variables
including \textit{single-variable usage context} (SVC),
\textit{multiple-variable usage context} (MVC), and
\textit{task-specific context} (TSC).
%
We initially construct a database to store
%the information about
the variables' names and the corresponding context information
extracted from a large corpus of JS code.
%
To recover the names, given a minified JS code, we first use
the \textit{SVC} and \textit{TSC} information to find in our
database the candidate names for each variable. Then, these candidates
for each variable are ranked by the likelihood that they are used
along with the candidates of other variables, in order to name the
variables in the same function by using~\textit{MVC}.
