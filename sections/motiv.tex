\section{Motivation and Approach Overview}
\label{example_section}



\begin{figure}[t]
	\centering
	\lstset{
		numbers=left,
		numberstyle= \tiny,
		keywordstyle= \color{blue!70},
		commentstyle= \color{red!50!green!50!blue!50},
		frame=shadowbox,
		rulesepcolor= \color{red!20!green!20!blue!20} ,
		xleftmargin=1.5em,xrightmargin=0em, aboveskip=1em,
		framexleftmargin=1.5em,
                numbersep= 5pt,
		language=Java,
    basicstyle=\scriptsize\ttfamily,
    numberstyle=\scriptsize\ttfamily,
    emphstyle=\bfseries,
                moredelim=**[is][\color{red}]{@}{@},
		escapeinside= {(*@}{@*)}
	}
	\begin{lstlisting}[]
function exportSelection(root, doc) {
  if (!root) {
      return null;
  }
  var selectionState = null, selection = doc.getSelection();
  if (selection.rangeCount > 0) {
      var range = selection.getRangeAt(0), preSelectionRange = range.cloneRange(), start;
      preSelectionRange.selectNodeContents(root);
      preSelectionRange.setEnd(range.startContainer, range.startOffset);
      start = preSelectionRange.toString().length;
      selectionState = {
          start: start,
          end: start + range.toString().length
      };
      if (this.doesRangeStartWithImages(range, doc)) {
          selectionState.startsWithImage = true;
      }
      var trailingImageCount = this.getTrailingImageCount(root, selectionState, range.endContainer, range.endOffset);
      if (trailingImageCount) {
        selectionState.trailingImageCount = trailingImageCount;
      }
      if (start !== 0) {
        var emptyBlocksIndex = this.getIndexRelativeToAdjacentEmptyBlocks(doc, root, range.startContainer, range.startOffset);
        if (emptyBlocksIndex !== -1) {
          selectionState.emptyBlocksIndex = emptyBlocksIndex;
        }...
        \end{lstlisting}
\vspace{-12pt}
\caption{An Original Code from a Project in GitHub}
\label{example_org}
\end{figure}


\begin{figure}[t]
	\centering
	\lstset{
		numbers=left,
		numberstyle= \tiny,
		keywordstyle= \color{blue!70},
		commentstyle= \color{red!50!green!50!blue!50},
		frame=shadowbox,
		rulesepcolor= \color{red!20!green!20!blue!20} ,
		xleftmargin=1.5em,xrightmargin=0em, aboveskip=1em,
		framexleftmargin=1.5em,
                numbersep= 5pt,
		language=Java,
    basicstyle=\scriptsize\ttfamily,
    numberstyle=\scriptsize\ttfamily,
    emphstyle=\bfseries,
                moredelim=**[is][\color{red}]{@}{@},
		escapeinside= {(*@}{@*)}
	}
	\begin{lstlisting}[]
function exportSelection(w, b) {
  if (!w) {
    return null;
  }
  var p = null, q = b.getSelection();
  if (q.rangeCount > 0) {
    var r = q.getRangeAt(0), d = r.cloneRange(), m;
    d.selectNodeContents(w);
    d.setEnd(r.startContainer, r.startOffset);
    m = d.toString().length;
    p = {
          start: m,
          end: m + r.toString().length
        };
    if (this.doesRangeStartWithImages(r, b)) {
       p.startsWithImage = true;
    }
    var a = this.getTrailingImageCount(w, p, r.endContainer, r.endOffset);
    if (a) {
      p.trailingImageCount = a;
    }
    if (m !== 0) {
      var y = this.getIndexRelativeToAdjacentEmptyBlocks(b, w, r.startContainer, r.startOffset);
      if (y !== -1) {
        p.emptyBlocksIndex = y;
      }...
\end{lstlisting}
\vspace{-12pt}
\caption{The Minified Code for the Code in Figure~\ref{example_org}}
\label{example_sim}
\end{figure}

Let us start with a real-world example to motivate our approach.
Figures~\ref{example_org} and~\ref{example_sim} show the original and
minified versions~of the JS function \code{exportSelection}.  The
function is aimed to export/retrieve the selection from a document.
%
In the minified code, all local variables were randomly renamed with
short and meaningless names, \eg \code{root} becomes \code{w},
\code{doc} becomes \code{b}, etc. by the minification tool,
\eg UglifyJS~\cite{uglifyJS}. This makes developers difficult to
comprehend it.


%
%The name chosen for a variable in the code should be {\em natural}
%(unsurprising) in the context~\cite{JSNaughty2017} and follow naming
%conventions~\cite{barr-codeconvention-fse14}, so that the de-minified
%code becomes easy to understand for developers.


%To achieve this goal, we conjecture that the meaningful names of
%minified variables could be observed in a large corpus of existing
%source code. This motivates us to conform our approach to a {\em
%  data-driven direction}, where we learn the names from original source
%code to recover the names for variables in the minified code.
%
%Indeed, for the minified code in Figure~\ref{example_sim}, all
%original names are found in our experimental dataset that contains
%322K JS files collected from 12K GitHub~projects.
%

\subsection{Observations}



We aim to recover the names of the variables in the minified
code. Such process is not trivial and affected by multiple factors.
Let us illustrate them via the following observations:


%1) a) variable "range"

%range.cloneRange(), range.toString()
%range.startContainer, range.startOffset

%b) variable "preSelectionRange"

%preSelectionRange.selectNodeContents(...)
%preSelectionRange.setEnd(...)

\textbf{O1}.{\em The fields and methods of a variable are kept intact
  after minification.} That is true if the names of the fields and
methods were minified, the corresponding field accesses and method
calls would not be valid anymore. For example, \code{cloneRange()} in
\code{r.cloneRange()} at line 7 and \code{startContainer} in
\code{r.startContainer} at line 9 in Figure~\ref{example_org} are
unchanged in Figure~\ref{example_sim}. Due to that, a model can rely
on the names of those properties of a variable/object to predict the
variable's name.
%
Moreover, the actual variable name must be in accordance with the
names of the accessed fields and called methods. For example, in the
original code in Figure~\ref{example_org}, the variable name
\code{range} makes a general sense in \code{range.startOffset} and
\code{range.endOffset} because a range could have a start offset and
an ending offset. The rationale is that in the orignal code, for easy
code comprehension, developers tend to use the naming conventions and
easy-to-remember names with respect to the surrounding names in the
code. In other words, the predicted name of a variable and those of
its properties (fields and methods) are in accordance. As another
example, \code{preSelectionRange} and \code{setEnd} are in accordance
in \code{preSelectionRange.setEnd} at line 9.

%\textit{Each individual variable has certain properties and plays
%  particular roles in the code. Thus, the name of a variable is
%  intuitively affected by its properties and roles}. The properties
%are the method calls or field accesses to which a variable of a
%certain type can access. If a method is called or a field is accessed
%by a variable, the name of the variable should be compatible with the
%method's or the field's name. For example, in our experimental
%dataset, the number of candidates that can call method
%\texttt{getData()} (lines 6 and 14) is only 7 out of 31 variables
%names found in a function named \texttt{getClipboardContent}. Such
%number is down to a \textit{single} candidate if we additionally
%consider that it can also access the fields \texttt{getData} (line 5)
%and \texttt{types} (line 11). Thus, \texttt{r} could be named as
%\texttt{dataTransfer}, which is the same name in the original code in
%Figure~\ref{example_org}. For the variable \texttt{f} that is created
%and assigned as an element of the array \texttt{types[]} at line 13,
%there are 4 candidates for such variable that can be used as an
%argument of the method named \texttt{getData()} (line~14). The number
%of candidates for \texttt{i}, which is the returned result of the call
%to \texttt{getData()} (line 6) and also has a field with the name
%\texttt{length} (line 7), is only 7.

%2)

%range = selection.getRangeAt(0)
%preSelectionRange = range.cloneRange()

%trailingImageCount = this.getTrailingImageCount(...)

%emptyBlocksIndex = this.getIndexRelativeToAdjacentEmptyBlocks (...)

%Tien

\textbf{O2}. \textit{In a function, a variable might collaborate with
  other variables to implement the function. Consequently, the
  recovering name for a variable might be influenced by the name of
  others}. Intuitively, since the variables are used together, their
names are often consistent with each other to achieve the
common task in the function.
%
In the example, in 28 possible pairs of candidates for \texttt{i} (7
candidates) and \texttt{f} (4 candidates), there are only 2 pairs of
candidates that are used to name two variables in the same function
in our dataset. One of them is the correct pair, which is
\texttt{legacyText} and \texttt{contentType}.
%
%experimental

\textbf{O3.} \textit{Within a function, e.g.,
  \texttt{getClipboardContent}, a variable name, e.g.,
  \texttt{contentType} is affected by the specific task of the
  function that is described by the function's
  name~\cite{sutton-fse15}}.~This is intuitive because the names of
variables are often~relevant~to the task that the variables are used
in the code~to~achieve. Such task is typically described with a
succinct function~name.
%containing the variables.
In Figure~\ref{example_org}, the task of~the function is to get the
clipboard's content, thus, it is named
\texttt{get\-ClipboardContent}. In our~dataset, there are 31
names being used to specify~the variables in function
\texttt{getClipboardContent}, \eg \texttt{data},
\texttt{dataTransfer}, \texttt{contentType}.
%\texttt{content}.
Meanwhile, the variable names \texttt{students}
or \texttt{salary} have never been used in the function with that
name.

%the variables named \texttt{salary} or \texttt{students} are never
%used in a function with the name of \texttt{getClipboardContent}.

Overall, these observations indicate that the names of the variables
in a particular function not only depend on {\em the task} in which
the variable is used to implement (called {\bf task-specific context}), but
their names are also affected by {\em their own properties and roles} in the
code (called {\bf single-variable usage context}) and on the {\em names of the
other variables} in the same function (called {\bf multiple-variable usage
  context}).

\subsection{Approach Overview}

From the observations, we propose an IR-based, data-driven approach to
recover the variables' names in a minified JS code based
on the contextual information
%of the variables
including \textit{single-variable usage context} (SVC),
\textit{multiple-variable usage context} (MVC), and
\textit{task-specific context} (TSC).
%
We initially construct a database to store
%the information about
the variables' names and the corresponding context information
extracted from a large corpus of JS code.
%
To recover the names, given a minified JS code, we first use
the \textit{SVC} and \textit{TSC} information to find in our
database the candidate names for each variable. Then, these candidates
for each variable are ranked by the likelihood that they are used
along with the candidates of other variables, in order to name the
variables in the same function by using~\textit{MVC}.
