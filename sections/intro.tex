\section{Introduction}
\label{intro:sec}

Understandability is an important software quality. Software
developers have to spend a significant portion of their efforts in
reading and comprehending source code. Beside the documentation,
meaningful names for variables and types are crucial for developers in
quickly grasping the essence of the code. Software organizations have
much emphasized on naming conventions and coding standards to ensure
meaningful variable names in source
code~\cite{barr-codeconvention-fse14}.

%An important aspect of program understanding is the names of the
%identifiers~used in the source code~\cite{sutton-fse15}. Meaningful
%identifiers help developers tremendously in quickly grasping the
%essence of the~code. Thus, naming conventions are strongly emphasized
%on prescribing how to choose meaningful variable names in coding
%standards~\cite{barr-codeconvention-fse14}.  These principles also
%apply to Web development.

%In modern Web development, program understanding plays an equally
%important role. 

In modern software development, some technologies require the exposure
of source code, e.g., in Web programming languages, the JavaScript
(JS) client code need to executed in the client side. To avoid the
exposure, the source code is obfuscated and/or minified such that the
variable names are replaced with short, opaque, and meaningless names.
The minification of the variable names hides the business logics from
the readers while maintaining the essence of the code. For Web
programming, the JS files are also more quickly loaded from the
servers for better performance.


%Web technologies and programming languages require the exposure of
%source code to Web browsers in the client side to be executed
%there. To avoid such exposure, the source code such as JavaScript (JS)
%files are often obfuscated in which the variable names are minified,
%\ie the variable names are replaced with short, opaque, and
%meaningless names. The intention has two folds. First, it makes the JS
%files smaller and thus is quickly loaded for better performance.
%Second, minification diminishes code readability to hide business
%logics from the readers, while maintaining the program semantics.
%
%\textbf{would be better to focus on the reason of making files small. In Web,JS code is transfer over the Internet from server to client to be executed there. Due to the limit in the bandwidth or the memory capacity of the 
%(mobile) device, JS code is normally minified to reduce its size. When being minified, the names are replaced ...}
%

For better code readability and understandability, especially when the
original source code is unavailable, there is a natural need to
automatically recover the minified code with meaningful variable
names. With the recovered names and types, the source code will be
more comprehensible and accessible for maintenance activities such
as code review, analysis, enhancement, and reuse.

%Due to those reasons, there is a natural need to automatically recover
%the minified code with meaningful variable names. When the original
%code is not available, with such recovery, the minified JS code will
%be made accessible for code~compre-\\hension as well as other maintenance
%activities such as~code review, reuse, analysis, and
%enhancement.

%Recognizing that need, researchers have been introducing the
%automatically recovering tools for variable names in JS code.


Several automated approaches have been proposed to automatically
recover the names of the variables in the minified source code.  The
approaches can be broadly classified into two directions: {\em
information retrieval} and {\em machine learning}.
JSNeat~\cite{icse19} follows an information retrieval (IR) approach to
recover names by searching for them in a large corpus of open-source
JS code. JSNeat integrates three types of contexts to match a variable
in given minified code against the corpus including 1) the context of
the properties and roles of the variable, 2) the context of that
variable and relations with other variables under recovery, and 3) the
context of the task of the function to which the variable contributes.
Despite its successes, due to the inherent limitation of the
information retrieval direction, JSNeat {\em cannot generate a new
variable name} that was not encountered in the corpus.

JSNice~\cite{JSNice2015}, following a probabilistic model (PM)
approach, is an automatic variable name recovery approach that
represents the program properties and relations among program entities
in a JS code as dependence graphs. JSNice~\cite{JSNice2015} uses a
probabilistic model with the program dependency graph including
variables and surrounding program entities. It formulates the problem
of variable name recovery as the structured prediction via conditional
random fields (CRFs)~\cite{JSNice2015}. Unfortunately, it still has
low accuracy.
%
In contrast, JSNaughty~\cite{JSNaughty2017} formulates the variable
name recovery problem for source code as a {\em statistical machine
translation} (SMT) from minified code to the recovered
code. JSNaughty~\cite{JSNaughty2017}'s phrase-based translation
approach cannot capture well the relations among the variables that
need to be recovered.

%We use multi-tasking framework to do the name prediction and the type
%predicting at the same time.

%We consider the code structure among the code 

%We consider the context (different types of relation) between
%variables that need to be recovered => EGCN

In this work, we present {\tool}, a deep learning (DL)-based variable
name recovery approach. We formulate the name recovery problem as the
dual-task learning between the variable name prediction model and the
type prediction model. Correct learning for one model can benefit for
the learning in the other and vice versa. The rationale is that the
name chosen for a variable in the code should be natural
(unsurprising) with respect to the type of that variable. Moreover, if
one knows the name of a variable, its type should be in accordance and
follow naming conventions. Exploring this duality can provide useful
constraints to predict both the variable names and their types.  To
build the variable name prediction model and the type prediction
model, we leverage a variant of the graph convolution network (GCN) to
model different kinds of relationships not only among the variables
but also among the types of the variables. Our models are
expected to have better predictive power than the CRF in JSNice and
SMT in JSNaughty, especially in modeling the relations among variables
and among types.
